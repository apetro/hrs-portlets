# This webapp won't work as is!

Yo! Heads up!

This `hrs-portlets-webapp` module builds a portlet `.war`.  That `.war` **won't work** if you deploy it.  If you're just looking for a demo .war to deploy to see this portlet in action for the first time, stop reading this long-winded README and instead go read the long-winded README in the `hrs-portlets-local-example` directory.  **That** .war *will* work as-is, and as a bonus, it's also the intended starting point for your own local build of this portlet.

The .war generated by this module won't work as-is when deployed to your portal because it's an "abstract" webapp.  It's everything you need to have a lovely human resources portlets suite *except* the implementation of the human resources system API. Without that implementation, the portlet web application feels lost and fails with sad lonely errors.

This abstract portlet module is the stuff that ostensibly can be shared across lots and lots of portals doing human resources systems integrations, regardless of which human resources systems those are.

To make this webapp work, you need to add one or more HRS API implementations.  You could do that by modifying the `pom.xml` of this module, but that's not a very good idea.  Instead, you can build a local project that declares dependency on this abstract .war and then adds your special sauce (such as your choice of HRS API implementations, your configuration, maybe your UI changes, etc.)

That "Maven Overlay" approach is kind of complicated, but take heart! There's an example of how to do this over in the `hrs-portlets-local-example`.

So.  Instead of copying this `hrs-portlets-webapp` module as your local starting point, you might be better off copying `hrs-portlets-local-example` as your starting point.  Take a look at that.

# Architecture

## Roles

How this portlet *doesn't* work is getting roles using the JSR-286 portlet API `isUserInRole()`.  Nope.

Rather, this portlet depends upon an implementation of its own `HrsRolesDao` API.

`HrsPreAuthenticatedGrantedAuthoritiesUserDetailsService` plugs in to bridge those read-from-HRS roles into Spring
Security.

Interesting roles:

* ROLE_VIEW_MANAGED_ABSENCES
* ROLE_VIEW_MANAGED_TIMES

* ROLE_VIEW_WEB_CLOCK
* ROLE_VIEW_TIME_CLOCK
* ROLE_VIEW_TIME_SHEET

*Except* ContactInfoController uses JSR-286 isUserInRole() (looking for a role the name of which is defined in a
portlet preference).

Spring Security authorization checks happen in annotations on the controllers, as in


    @Secured("ROLE_VIEW_MANAGED_ABSENCES")
    // (some method that user can only execute if in that role)

and in the JSP pages, as in

    <sec:authorize ifAnyGranted="ROLE_VIEW_ABSENCE_HISTORIES">
      <!-- JSP stuff that will only be evaluated if user is in that role -->
    </sec:authorize>


